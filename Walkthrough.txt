AsyncAweight - An Exploratory Async/ Await Implementation
---------------------------------------------------------

Since C# 8 (-ish), "Task" has had no special meaning to the C# compiler, and all the 
implementation (except code-rewriting) should be able to be done in "userland" code.

This walkthrough was to see how far we could get! - and how much or little "magic" is 
involved!

The limitations I set out for the implementation:
  * Only value-returning operations were to be implemented
  * Cancellation/ CancellationToken were not to be considered.
  * Efficiency was not a large concern.

Each stage has been checked in as a separate commit; to see the evolution of the code,
restore the earliest revision and move forward one revision at a time.

1: First Stage - something that compiles!
-----------------------------------------

I started off with a pseudo "async main", with a call to a dummy method we'd like to run 
asynchronously.  The reason for not using the language's recently-provided "async main" 
functionality was to eliminate as much hidden logic (i.e. "magic"!) as possible.  The 
polling of "done" for completion is not pretty, and maybe I'll clean that up later.

From there, I implemented methods as the compiler complained about them not existing, 
until I had a program that compiled.  The syntax "await someOperation()" kicks off some
compile-time duck-typing by calling ".GetAwaiter()" on the result of someOperation().

In this experiment, "Tusk<T>" is the equivalent of "Task<T>" and "Aweighter<T>" is the 
result of calling "Tusk<T>.GetAwaiter()".


2: Stage Two - something that runs! (ish!)
------------------------------------------

The easiest way to return from an asychronous task is not to be asynchronous at all! 
Normally, that's done via "Task<T>.FromResult(...)" - here, "Tusk<T>.FromResult(...)"
will perform the same job.  To do this, we have to flesh out Tusk and Aweighter:
Tusk needs some way of recording whether the operation has completed and the result,
and Aweighter needs to be connected to the Tusk.  Much like in Main, I've written 
GetResult to poll if the result isn't currently available; and I've fleshed out the test 
to perform two asynchronous operations sequentially.

The code in AsyncMain and GetNameAsink is rewritten by the compiler into classes 
implementing a state machine that steps through the code as operations complete. Part of
this implementation is a "Happy path" optimisation where, if an operation is already
marked as completed, it will continue with the rest of the function straightaway rather
than queuing it for later - this is why we don't need to define the method
"Aweighter<T>.OnCompleted(...)" quite yet.


3: Asychronous operations get real!
-----------------------------------

The most common reason for using/ needing asynchronous operations is to deal with I/O.
While waiting for the device (keyboard, disk, network, etc...) to come back with an
answer, there's nothing else that the thread can do apart from wait. For the operating 
system, a "blocking" system call simply won't schedule the thread to run again until
its result is available.

In this example, we'll use a file watcher to emulate our input device. We'll be watching
for changes to the "C:\temp\touch.txt" file, and changes to this will be used as the 
result of our asynchronous function.

In order to get this data returned from an asynchronous task (ah, Tusk!), we'll be using
a TuskCompletionSource<T> (analogous to a TaskCompletionSource<T>).  This is really 
handy class for making any sort of asynchronous operation work with async/ await.

The changes we need to the Asink/Aweight library are really quite small. The 
TuskCompletionSource sets the result on its Tusk by means of internal access to SetResult,
Aweighter has now to be able to set the continuation Action of the Tusk (again,
via internal access), and it all Just Works....!

